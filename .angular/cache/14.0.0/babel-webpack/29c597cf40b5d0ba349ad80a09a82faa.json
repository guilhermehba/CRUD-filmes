{"ast":null,"code":"import _objectSpread from \"C:/Users/guilh/dev/filmes-crud/curso-angular/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createClass from \"C:/Users/guilh/dev/filmes-crud/curso-angular/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/guilh/dev/filmes-crud/curso-angular/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Directive, Output, Input, NgModule } from '@angular/core';\nimport { of, fromEvent } from 'rxjs';\nimport { mergeMap, map, tap, filter, throttleTime } from 'rxjs/operators';\nvar NgxInfiniteScrollService = /*#__PURE__*/(function () {\n  var NgxInfiniteScrollService = /*#__PURE__*/_createClass(function NgxInfiniteScrollService() {\n    _classCallCheck(this, NgxInfiniteScrollService);\n  });\n\n  NgxInfiniteScrollService.ɵfac = function NgxInfiniteScrollService_Factory(t) {\n    return new (t || NgxInfiniteScrollService)();\n  };\n\n  NgxInfiniteScrollService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxInfiniteScrollService,\n    factory: NgxInfiniteScrollService.ɵfac,\n    providedIn: 'root'\n  });\n  return NgxInfiniteScrollService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction resolveContainerElement(selector, scrollWindow, defaultElement, fromRoot) {\n  var hasWindow = window && !!window.document && window.document.documentElement;\n  var container = hasWindow && scrollWindow ? window : defaultElement;\n\n  if (selector) {\n    var containerIsString = selector && hasWindow && typeof selector === 'string';\n    container = containerIsString ? findElement(selector, defaultElement.nativeElement, fromRoot) : selector;\n\n    if (!container) {\n      throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');\n    }\n  }\n\n  return container;\n}\n\nfunction findElement(selector, customRoot, fromRoot) {\n  var rootEl = fromRoot ? window.document : customRoot;\n  return rootEl.querySelector(selector);\n}\n\nfunction inputPropChanged(prop) {\n  return prop && !prop.firstChange;\n}\n\nfunction hasWindowDefined() {\n  return typeof window !== 'undefined';\n}\n\nvar VerticalProps = {\n  clientHeight: \"clientHeight\",\n  offsetHeight: \"offsetHeight\",\n  scrollHeight: \"scrollHeight\",\n  pageYOffset: \"pageYOffset\",\n  offsetTop: \"offsetTop\",\n  scrollTop: \"scrollTop\",\n  top: \"top\"\n};\nvar HorizontalProps = {\n  clientHeight: \"clientWidth\",\n  offsetHeight: \"offsetWidth\",\n  scrollHeight: \"scrollWidth\",\n  pageYOffset: \"pageXOffset\",\n  offsetTop: \"offsetLeft\",\n  scrollTop: \"scrollLeft\",\n  top: \"left\"\n};\n\nvar AxisResolver = /*#__PURE__*/function () {\n  function AxisResolver() {\n    var vertical = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    _classCallCheck(this, AxisResolver);\n\n    this.vertical = vertical;\n    this.propsMap = vertical ? VerticalProps : HorizontalProps;\n  }\n\n  _createClass(AxisResolver, [{\n    key: \"clientHeightKey\",\n    value: function clientHeightKey() {\n      return this.propsMap.clientHeight;\n    }\n  }, {\n    key: \"offsetHeightKey\",\n    value: function offsetHeightKey() {\n      return this.propsMap.offsetHeight;\n    }\n  }, {\n    key: \"scrollHeightKey\",\n    value: function scrollHeightKey() {\n      return this.propsMap.scrollHeight;\n    }\n  }, {\n    key: \"pageYOffsetKey\",\n    value: function pageYOffsetKey() {\n      return this.propsMap.pageYOffset;\n    }\n  }, {\n    key: \"offsetTopKey\",\n    value: function offsetTopKey() {\n      return this.propsMap.offsetTop;\n    }\n  }, {\n    key: \"scrollTopKey\",\n    value: function scrollTopKey() {\n      return this.propsMap.scrollTop;\n    }\n  }, {\n    key: \"topKey\",\n    value: function topKey() {\n      return this.propsMap.top;\n    }\n  }]);\n\n  return AxisResolver;\n}();\n\nfunction shouldTriggerEvents(alwaysCallback, shouldFireScrollEvent, isTriggeredCurrentTotal) {\n  if (alwaysCallback && shouldFireScrollEvent) {\n    return true;\n  }\n\n  if (!isTriggeredCurrentTotal && shouldFireScrollEvent) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction createResolver(_ref) {\n  var windowElement = _ref.windowElement,\n      axis = _ref.axis;\n  return createResolverWithContainer({\n    axis: axis,\n    isWindow: isElementWindow(windowElement)\n  }, windowElement);\n}\n\nfunction createResolverWithContainer(resolver, windowElement) {\n  var container = resolver.isWindow || windowElement && !windowElement.nativeElement ? windowElement : windowElement.nativeElement;\n  return _objectSpread(_objectSpread({}, resolver), {}, {\n    container: container\n  });\n}\n\nfunction isElementWindow(windowElement) {\n  var isWindow = ['Window', 'global'].some(function (obj) {\n    return Object.prototype.toString.call(windowElement).includes(obj);\n  });\n  return isWindow;\n}\n\nfunction getDocumentElement(isContainerWindow, windowElement) {\n  return isContainerWindow ? windowElement.document.documentElement : null;\n}\n\nfunction calculatePoints(element, resolver) {\n  var height = extractHeightForElement(resolver);\n  return resolver.isWindow ? calculatePointsForWindow(height, element, resolver) : calculatePointsForElement(height, element, resolver);\n}\n\nfunction calculatePointsForWindow(height, element, resolver) {\n  var axis = resolver.axis,\n      container = resolver.container,\n      isWindow = resolver.isWindow;\n\n  var _extractHeightPropKey = extractHeightPropKeys(axis),\n      offsetHeightKey = _extractHeightPropKey.offsetHeightKey,\n      clientHeightKey = _extractHeightPropKey.clientHeightKey; // scrolled until now / current y point\n\n\n  var scrolled = height + getElementPageYOffset(getDocumentElement(isWindow, container), axis, isWindow); // total height / most bottom y point\n\n  var nativeElementHeight = getElementHeight(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);\n  var totalToScroll = getElementOffsetTop(element.nativeElement, axis, isWindow) + nativeElementHeight;\n  return {\n    height: height,\n    scrolled: scrolled,\n    totalToScroll: totalToScroll,\n    isWindow: isWindow\n  };\n}\n\nfunction calculatePointsForElement(height, element, resolver) {\n  var axis = resolver.axis,\n      container = resolver.container; // perhaps use container.offsetTop instead of 'scrollTop'\n\n  var scrolled = container[axis.scrollTopKey()];\n  var totalToScroll = container[axis.scrollHeightKey()];\n  return {\n    height: height,\n    scrolled: scrolled,\n    totalToScroll: totalToScroll,\n    isWindow: false\n  };\n}\n\nfunction extractHeightPropKeys(axis) {\n  return {\n    offsetHeightKey: axis.offsetHeightKey(),\n    clientHeightKey: axis.clientHeightKey()\n  };\n}\n\nfunction extractHeightForElement(_ref2) {\n  var container = _ref2.container,\n      isWindow = _ref2.isWindow,\n      axis = _ref2.axis;\n\n  var _extractHeightPropKey2 = extractHeightPropKeys(axis),\n      offsetHeightKey = _extractHeightPropKey2.offsetHeightKey,\n      clientHeightKey = _extractHeightPropKey2.clientHeightKey;\n\n  return getElementHeight(container, isWindow, offsetHeightKey, clientHeightKey);\n}\n\nfunction getElementHeight(elem, isWindow, offsetHeightKey, clientHeightKey) {\n  if (isNaN(elem[offsetHeightKey])) {\n    var docElem = getDocumentElement(isWindow, elem);\n    return docElem ? docElem[clientHeightKey] : 0;\n  } else {\n    return elem[offsetHeightKey];\n  }\n}\n\nfunction getElementOffsetTop(elem, axis, isWindow) {\n  var topKey = axis.topKey(); // elem = elem.nativeElement;\n\n  if (!elem.getBoundingClientRect) {\n    // || elem.css('none')) {\n    return;\n  }\n\n  return elem.getBoundingClientRect()[topKey] + getElementPageYOffset(elem, axis, isWindow);\n}\n\nfunction getElementPageYOffset(elem, axis, isWindow) {\n  var pageYOffset = axis.pageYOffsetKey();\n  var scrollTop = axis.scrollTopKey();\n  var offsetTop = axis.offsetTopKey();\n\n  if (isNaN(window.pageYOffset)) {\n    return getDocumentElement(isWindow, elem)[scrollTop];\n  } else if (elem.ownerDocument) {\n    return elem.ownerDocument.defaultView[pageYOffset];\n  } else {\n    return elem[offsetTop];\n  }\n}\n\nfunction shouldFireScrollEvent(container) {\n  var distance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    down: 0,\n    up: 0\n  };\n  var scrollingDown = arguments.length > 2 ? arguments[2] : undefined;\n  var remaining;\n  var containerBreakpoint;\n\n  if (container.totalToScroll <= 0) {\n    return false;\n  }\n\n  var scrolledUntilNow = container.isWindow ? container.scrolled : container.height + container.scrolled;\n\n  if (scrollingDown) {\n    remaining = (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;\n    var distanceDown = distance !== null && distance !== void 0 && distance.down ? distance.down : 0;\n    containerBreakpoint = distanceDown / 10;\n  } else {\n    var totalHiddenContentHeight = container.scrolled + (container.totalToScroll - scrolledUntilNow);\n    remaining = container.scrolled / totalHiddenContentHeight;\n    var distanceUp = distance !== null && distance !== void 0 && distance.up ? distance.up : 0;\n    containerBreakpoint = distanceUp / 10;\n  }\n\n  var shouldFireEvent = remaining <= containerBreakpoint;\n  return shouldFireEvent;\n}\n\nfunction isScrollingDownwards(lastScrollPosition, container) {\n  return lastScrollPosition < container.scrolled;\n}\n\nfunction getScrollStats(lastScrollPosition, container, distance) {\n  var scrollDown = isScrollingDownwards(lastScrollPosition, container);\n  return {\n    fire: shouldFireScrollEvent(container, distance, scrollDown),\n    scrollDown: scrollDown\n  };\n}\n\nfunction updateScrollPosition(position, scrollState) {\n  return scrollState.lastScrollPosition = position;\n}\n\nfunction updateTotalToScroll(totalToScroll, scrollState) {\n  if (scrollState.lastTotalToScroll !== totalToScroll) {\n    scrollState.lastTotalToScroll = scrollState.totalToScroll;\n    scrollState.totalToScroll = totalToScroll;\n  }\n}\n\nfunction isSameTotalToScroll(scrollState) {\n  return scrollState.totalToScroll === scrollState.lastTotalToScroll;\n}\n\nfunction updateTriggeredFlag(scroll, scrollState, triggered, isScrollingDown) {\n  if (isScrollingDown) {\n    scrollState.triggered.down = scroll;\n  } else {\n    scrollState.triggered.up = scroll;\n  }\n}\n\nfunction isTriggeredScroll(totalToScroll, scrollState, isScrollingDown) {\n  return isScrollingDown ? scrollState.triggered.down === totalToScroll : scrollState.triggered.up === totalToScroll;\n}\n\nfunction updateScrollState(scrollState, scrolledUntilNow, totalToScroll) {\n  updateScrollPosition(scrolledUntilNow, scrollState);\n  updateTotalToScroll(totalToScroll, scrollState); // const isSameTotal = isSameTotalToScroll(scrollState);\n  // if (!isSameTotal) {\n  //   updateTriggeredFlag(scrollState, false, isScrollingDown);\n  // }\n}\n\nvar ScrollState = /*#__PURE__*/function () {\n  function ScrollState(_ref3) {\n    var totalToScroll = _ref3.totalToScroll;\n\n    _classCallCheck(this, ScrollState);\n\n    this.lastScrollPosition = 0;\n    this.lastTotalToScroll = 0;\n    this.totalToScroll = 0;\n    this.triggered = {\n      down: 0,\n      up: 0\n    };\n    this.totalToScroll = totalToScroll;\n  }\n\n  _createClass(ScrollState, [{\n    key: \"updateScrollPosition\",\n    value: function updateScrollPosition(position) {\n      return this.lastScrollPosition = position;\n    }\n  }, {\n    key: \"updateTotalToScroll\",\n    value: function updateTotalToScroll(totalToScroll) {\n      if (this.lastTotalToScroll !== totalToScroll) {\n        this.lastTotalToScroll = this.totalToScroll;\n        this.totalToScroll = totalToScroll;\n      }\n    }\n  }, {\n    key: \"updateScroll\",\n    value: function updateScroll(scrolledUntilNow, totalToScroll) {\n      this.updateScrollPosition(scrolledUntilNow);\n      this.updateTotalToScroll(totalToScroll);\n    }\n  }, {\n    key: \"updateTriggeredFlag\",\n    value: function updateTriggeredFlag(scroll, isScrollingDown) {\n      if (isScrollingDown) {\n        this.triggered.down = scroll;\n      } else {\n        this.triggered.up = scroll;\n      }\n    }\n  }, {\n    key: \"isTriggeredScroll\",\n    value: function isTriggeredScroll(totalToScroll, isScrollingDown) {\n      return isScrollingDown ? this.triggered.down === totalToScroll : this.triggered.up === totalToScroll;\n    }\n  }]);\n\n  return ScrollState;\n}();\n\nfunction createScroller(config) {\n  var scrollContainer = config.scrollContainer,\n      scrollWindow = config.scrollWindow,\n      element = config.element,\n      fromRoot = config.fromRoot;\n  var resolver = createResolver({\n    axis: new AxisResolver(!config.horizontal),\n    windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot)\n  });\n  var scrollState = new ScrollState({\n    totalToScroll: calculatePoints(element, resolver)\n  });\n  var options = {\n    container: resolver.container,\n    throttle: config.throttle\n  };\n  var distance = {\n    up: config.upDistance,\n    down: config.downDistance\n  };\n  return attachScrollEvent(options).pipe(mergeMap(function () {\n    return of(calculatePoints(element, resolver));\n  }), map(function (positionStats) {\n    return toInfiniteScrollParams(scrollState.lastScrollPosition, positionStats, distance);\n  }), tap(function (_ref4) {\n    var stats = _ref4.stats;\n    return scrollState.updateScroll(stats.scrolled, stats.totalToScroll);\n  }), filter(function (_ref5) {\n    var fire = _ref5.fire,\n        scrollDown = _ref5.scrollDown,\n        totalToScroll = _ref5.stats.totalToScroll;\n    return shouldTriggerEvents(config.alwaysCallback, fire, scrollState.isTriggeredScroll(totalToScroll, scrollDown));\n  }), tap(function (_ref6) {\n    var scrollDown = _ref6.scrollDown,\n        totalToScroll = _ref6.stats.totalToScroll;\n    scrollState.updateTriggeredFlag(totalToScroll, scrollDown);\n  }), map(toInfiniteScrollAction));\n}\n\nfunction attachScrollEvent(options) {\n  var obs = fromEvent(options.container, 'scroll'); // For an unknown reason calling `sampleTime()` causes trouble for many users, even with `options.throttle = 0`.\n  // Let's avoid calling the function unless needed.\n  // Replacing with throttleTime seems to solve the problem\n  // See https://github.com/orizens/ngx-infinite-scroll/issues/198\n\n  if (options.throttle) {\n    obs = obs.pipe(throttleTime(options.throttle, undefined, {\n      leading: true,\n      trailing: true\n    }));\n  }\n\n  return obs;\n}\n\nfunction toInfiniteScrollParams(lastScrollPosition, stats, distance) {\n  var _getScrollStats = getScrollStats(lastScrollPosition, stats, distance),\n      scrollDown = _getScrollStats.scrollDown,\n      fire = _getScrollStats.fire;\n\n  return {\n    scrollDown: scrollDown,\n    fire: fire,\n    stats: stats\n  };\n}\n\nvar InfiniteScrollActions = {\n  DOWN: '[NGX_ISE] DOWN',\n  UP: '[NGX_ISE] UP'\n};\n\nfunction toInfiniteScrollAction(response) {\n  var scrollDown = response.scrollDown,\n      currentScrollPosition = response.stats.scrolled;\n  return {\n    type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,\n    payload: {\n      currentScrollPosition: currentScrollPosition\n    }\n  };\n}\n\nvar InfiniteScrollDirective = /*#__PURE__*/(function () {\n  var InfiniteScrollDirective = /*#__PURE__*/function () {\n    function InfiniteScrollDirective(element, zone) {\n      _classCallCheck(this, InfiniteScrollDirective);\n\n      this.element = element;\n      this.zone = zone;\n      this.scrolled = new EventEmitter();\n      this.scrolledUp = new EventEmitter();\n      this.infiniteScrollDistance = 2;\n      this.infiniteScrollUpDistance = 1.5;\n      this.infiniteScrollThrottle = 150;\n      this.infiniteScrollDisabled = false;\n      this.infiniteScrollContainer = null;\n      this.scrollWindow = true;\n      this.immediateCheck = false;\n      this.horizontal = false;\n      this.alwaysCallback = false;\n      this.fromRoot = false;\n    }\n\n    _createClass(InfiniteScrollDirective, [{\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        if (!this.infiniteScrollDisabled) {\n          this.setup();\n        }\n      }\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(_ref7) {\n        var infiniteScrollContainer = _ref7.infiniteScrollContainer,\n            infiniteScrollDisabled = _ref7.infiniteScrollDisabled,\n            infiniteScrollDistance = _ref7.infiniteScrollDistance;\n        var containerChanged = inputPropChanged(infiniteScrollContainer);\n        var disabledChanged = inputPropChanged(infiniteScrollDisabled);\n        var distanceChanged = inputPropChanged(infiniteScrollDistance);\n        var shouldSetup = !disabledChanged && !this.infiniteScrollDisabled || disabledChanged && !infiniteScrollDisabled.currentValue || distanceChanged;\n\n        if (containerChanged || disabledChanged || distanceChanged) {\n          this.destroyScroller();\n\n          if (shouldSetup) {\n            this.setup();\n          }\n        }\n      }\n    }, {\n      key: \"setup\",\n      value: function setup() {\n        var _this = this;\n\n        if (hasWindowDefined()) {\n          this.zone.runOutsideAngular(function () {\n            _this.disposeScroller = createScroller({\n              fromRoot: _this.fromRoot,\n              alwaysCallback: _this.alwaysCallback,\n              disable: _this.infiniteScrollDisabled,\n              downDistance: _this.infiniteScrollDistance,\n              element: _this.element,\n              horizontal: _this.horizontal,\n              scrollContainer: _this.infiniteScrollContainer,\n              scrollWindow: _this.scrollWindow,\n              throttle: _this.infiniteScrollThrottle,\n              upDistance: _this.infiniteScrollUpDistance\n            }).subscribe(function (payload) {\n              return _this.zone.run(function () {\n                return _this.handleOnScroll(payload);\n              });\n            });\n          });\n        }\n      }\n    }, {\n      key: \"handleOnScroll\",\n      value: function handleOnScroll(_ref8) {\n        var type = _ref8.type,\n            payload = _ref8.payload;\n\n        switch (type) {\n          case InfiniteScrollActions.DOWN:\n            return this.scrolled.emit(payload);\n\n          case InfiniteScrollActions.UP:\n            return this.scrolledUp.emit(payload);\n\n          default:\n            return;\n        }\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.destroyScroller();\n      }\n    }, {\n      key: \"destroyScroller\",\n      value: function destroyScroller() {\n        if (this.disposeScroller) {\n          this.disposeScroller.unsubscribe();\n        }\n      }\n    }]);\n\n    return InfiniteScrollDirective;\n  }();\n\n  InfiniteScrollDirective.ɵfac = function InfiniteScrollDirective_Factory(t) {\n    return new (t || InfiniteScrollDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  InfiniteScrollDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: InfiniteScrollDirective,\n    selectors: [[\"\", \"infiniteScroll\", \"\"], [\"\", \"infinite-scroll\", \"\"], [\"\", \"data-infinite-scroll\", \"\"]],\n    inputs: {\n      infiniteScrollDistance: \"infiniteScrollDistance\",\n      infiniteScrollUpDistance: \"infiniteScrollUpDistance\",\n      infiniteScrollThrottle: \"infiniteScrollThrottle\",\n      infiniteScrollDisabled: \"infiniteScrollDisabled\",\n      infiniteScrollContainer: \"infiniteScrollContainer\",\n      scrollWindow: \"scrollWindow\",\n      immediateCheck: \"immediateCheck\",\n      horizontal: \"horizontal\",\n      alwaysCallback: \"alwaysCallback\",\n      fromRoot: \"fromRoot\"\n    },\n    outputs: {\n      scrolled: \"scrolled\",\n      scrolledUp: \"scrolledUp\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return InfiniteScrollDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar InfiniteScrollModule = /*#__PURE__*/(function () {\n  var InfiniteScrollModule = /*#__PURE__*/_createClass(function InfiniteScrollModule() {\n    _classCallCheck(this, InfiniteScrollModule);\n  });\n\n  InfiniteScrollModule.ɵfac = function InfiniteScrollModule_Factory(t) {\n    return new (t || InfiniteScrollModule)();\n  };\n\n  InfiniteScrollModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: InfiniteScrollModule\n  });\n  InfiniteScrollModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [],\n    imports: [[]]\n  });\n  return InfiniteScrollModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of ngx-infinite-scroll\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { InfiniteScrollDirective, InfiniteScrollModule, NgxInfiniteScrollService }; //# sourceMappingURL=ngx-infinite-scroll.mjs.map","map":null,"metadata":{},"sourceType":"module"}